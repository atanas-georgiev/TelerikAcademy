using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
    class AggressionCatalyst : Supplement
    {
        public AggressionCatalyst()
            : base(0, 0, 3)
        {
        }
    }
    public class Dog : Unit
    {
        const int DogPower = 5;
        const int DogAggression = 2;
        const int DogHealth = 4;
        public Dog(string id) :
            base(id, UnitClassification.Biological, Dog.DogHealth, Dog.DogPower, Dog.DogAggression)
        {
        }
    }
    class HealthCatalyst : Supplement
    {
        public HealthCatalyst()
            : base(0, 3, 0)
        {
        }
    }
    public class HoldingPen
    {
        private List<Unit> containedUnits = new List<Unit>();
        public void ParseCommand(string command)
        {
            string[] commandWordSeparators = new string[] { " " };
            string[] commandWords = command.Split(commandWordSeparators, StringSplitOptions.RemoveEmptyEntries);
            DispatchCommand(commandWords);
        }
        protected virtual void DispatchCommand(string[] commandWords)
        {
            switch (commandWords[0])
            {
                case "insert":
                    this.ExecuteInsertUnitCommand(commandWords);
                    break;
                case "proceed":
                    this.ExecuteProceedSingleIterationCommand();
                    break;
                case "supplement":
                    this.ExecuteAddSupplementCommand(commandWords);
                    break;
                case "status":
                    this.ExecutePrintStatusCommand();
                    break;
                default:
                    break;
            }
        }
        private void ExecutePrintStatusCommand()
        {
            foreach (var unit in this.containedUnits)
            {
                Console.WriteLine(unit);
            }
        }
        protected virtual void ExecuteAddSupplementCommand(string[] commandWords)
        {
          //  throw new NotImplementedException();
        }
        protected virtual void ExecuteProceedSingleIterationCommand()
        {
            var containedUnitsInfo = this.containedUnits.Select((unit) => unit.Info);
            IEnumerable<Interaction> requestedInteractions =
                from unit in this.containedUnits
                select unit.DecideInteraction(containedUnitsInfo);
            requestedInteractions = requestedInteractions.Where((interaction) => interaction != Interaction.PassiveInteraction);
            foreach (var interaction in requestedInteractions)
            {
                this.ProcessSingleInteraction(interaction);
            }
            this.containedUnits.RemoveAll((unit) => unit.IsDestroyed);
        }
        protected virtual void ProcessSingleInteraction(Interaction interaction)
        {
            switch (interaction.InteractionType)
            {
                case InteractionType.Attack:
                    Unit targetUnit = this.GetUnit(interaction.TargetUnit);
                    targetUnit.DecreaseBaseHealth(interaction.SourceUnit.Power);
                    break;
                default:
                    break;
            }
        }
        protected Unit GetUnit(string unitId)
        {
            return this.containedUnits.FirstOrDefault((unit) => unit.Id == unitId);
        }
        protected Unit GetUnit(UnitInfo unitInfo)
        {
            return this.GetUnit(unitInfo.Id);
            //return this.containedUnits.FirstOrDefault((unit) => unit.Id == unitInfo.Id);
        }
        protected virtual void ExecuteInsertUnitCommand(string[] commandWords)
        {
            switch (commandWords[1])
            {
                case "Dog":
                    var dog = new Dog(commandWords[2]);
                    this.InsertUnit(dog);
                    break;
                case "Human":
                    var human = new Human(commandWords[2]);
                    this.InsertUnit(human);
                    break;
                default:
                    break;
            }
        }
        protected void InsertUnit(Unit unit)
        {
            this.containedUnits.Add(unit);
        }
    }
    class HoldingPenModified : HoldingPen
    {
        protected override void DispatchCommand(string[] commandWords)
        {
            try
            { 
                base.DispatchCommand(commandWords); 
            }
            catch
            {
            }            
        }
        protected override void ExecuteAddSupplementCommand(string[] commandWords)
        {
            try
            {
                var unit = this.GetUnit(commandWords[2]);
                switch (commandWords[1])
                {
                    case "PowerCatalyst":
                        unit.AddSupplement(new PowerCatalyst());
                        break;
                    case "HealthCatalyst":
                        unit.AddSupplement(new HealthCatalyst());
                        break;
                    case "AggressionCatalyst":
                        unit.AddSupplement(new AggressionCatalyst());
                        break;
                    case "Weapon":
                        unit.AddSupplement(new Weapon());
                        break;
                    default:
                        break;
                }
            }
            catch
            {
            }
        }
        protected override void ExecuteInsertUnitCommand(string[] commandWords)
        {
            try
            {
                switch (commandWords[1])
                {
                    case "Tank":
                        var tank = new Tank(commandWords[2]);
                        this.InsertUnit(tank);
                        break;
                    case "Marine":
                        var marine = new Marine(commandWords[2]);
                        this.InsertUnit(marine);
                        break;
                    case "Parasite":
                        var parasite = new Parasite(commandWords[2]);
                        this.InsertUnit(parasite);
                        break;
                    case "Queen":
                        var queen = new Queen(commandWords[2]);
                        this.InsertUnit(queen);
                        break;
                    default:
                        base.ExecuteInsertUnitCommand(commandWords);
                        break;
                }
            }
            catch
            {
            }
        }
        protected override void ProcessSingleInteraction(Interaction interaction)
        {
            try
            {
                switch (interaction.InteractionType)
                {
                    case InteractionType.Attack:
                        Unit targetUnit = this.GetUnit(interaction.TargetUnit);
                        targetUnit.DecreaseBaseHealth(interaction.SourceUnit.Power);
                        break;
                    case InteractionType.Infest:
                        Unit targetUnit1 = this.GetUnit(interaction.TargetUnit);
                        if (InfestationRequirements.RequiredClassificationToInfest(targetUnit1.UnitClassification) == interaction.SourceUnit.UnitClassification)
                        {
                            targetUnit1.AddSupplement(new InfestationSpores());
                        }
                        break;
                    default:
                        break;
                }
            }
            catch
            {
            }
        }
    }
    public class Human : Unit
    {
        public const int HumanPower = 4;
        public const int HumanAggression = 1;
        public const int HumanHealth = 10;
        public Human(string id)
            : base(id, UnitClassification.Biological, Human.HumanHealth, Human.HumanPower, Human.HumanAggression)
        {
        }
    }
    public static class InfestationRequirements
    {
        public static UnitClassification RequiredClassificationToInfest(UnitClassification targetUnit)
        {
            switch (targetUnit)
            {
                case UnitClassification.Biological:
                    return UnitClassification.Biological;
                case UnitClassification.Mechanical:
                    return UnitClassification.Psionic;
                case UnitClassification.Psionic:
                    return UnitClassification.Psionic;
                default:
                    throw new InvalidOperationException("Unknown unit classification: " + targetUnit);
            }
        }
    }
    class InfestationSpores : Supplement
    {
        public InfestationSpores()
            : base(-1, 0, 20)
        {
        }
        public override void ReactTo1(ISupplement otherSupplement)
        {
            if (otherSupplement is InfestationSpores)
            {
                var a = (Supplement)otherSupplement;
                a.aggressionEffect = 0;
                a.powerEffect = 0;
            }
        }
    }
    public class Interaction
    {
        public const Interaction PassiveInteraction = null;
        public UnitInfo SourceUnit { get; private set; }
        public UnitInfo TargetUnit { get; private set; }
        public InteractionType InteractionType { get; private set; }
        public Interaction(UnitInfo sourceUnitInfo, UnitInfo targetUnitInfo, InteractionType type)
        {
            this.SourceUnit = sourceUnitInfo;
            this.TargetUnit = targetUnitInfo;
            this.InteractionType = type;
        }
    }
    public enum InteractionType
    {
        Attack,
        Infest,
    }
    public interface ISupplement
    {
        void ReactTo(ISupplement otherSupplement);
        int PowerEffect { get; }
        int HealthEffect { get; }
        int AggressionEffect { get; }
    }
    class Marine : Human
    {
        public Marine(string name)
            : base(name)
        {
            this.AddSupplement(new WeaponrySkill());
        }
        protected override bool CanAttackUnit(UnitInfo unit)
        {
            bool attackUnit = false;
            if (this.Id != unit.Id)
            {
                if (this.Aggression >= unit.Power)
                {
                    attackUnit = true;
                }
            }
            return attackUnit;
        }
        public override Interaction DecideInteraction(IEnumerable<UnitInfo> units)
        {
            return base.DecideInteraction(units);
        }
        public override void AddSupplement(ISupplement newSupplement)
        {
            base.AddSupplement(newSupplement);
        }
        protected override UnitInfo GetOptimalAttackableUnit(IEnumerable<UnitInfo> attackableUnits)
        {
            var res = attackableUnits.OrderBy(x => x.Health).Last<UnitInfo>();
            return res;
        }
    }
    class Parasite : Unit
    {
        public Parasite(string name)
            : base(name, UnitClassification.Biological, 1, 1, 1)
        {
        }
        protected override bool CanAttackUnit(UnitInfo unit)
        {
            bool attackUnit = false;
            if (this.Id != unit.Id && unit.UnitClassification == UnitClassification.Biological)
            {
                attackUnit = true;
            }
            return attackUnit;
        }
        public override Interaction DecideInteraction(IEnumerable<UnitInfo> units)
        {
            IEnumerable<UnitInfo> attackableUnits = units.Where((unit) => this.CanAttackUnit(unit));
            UnitInfo optimalAttackableUnit = GetOptimalAttackableUnit(attackableUnits);
            if (optimalAttackableUnit.Id != null)
            {
                return new Interaction(new UnitInfo(this), optimalAttackableUnit, InteractionType.Infest);
            }
            return Interaction.PassiveInteraction;
        }
        public override void AddSupplement(ISupplement newSupplement)
        {
            base.AddSupplement(newSupplement);
        }
        protected override UnitInfo GetOptimalAttackableUnit(IEnumerable<UnitInfo> attackableUnits)
        {
            var res = attackableUnits.OrderBy(x => x.Health).LastOrDefault<UnitInfo>();
            return res;
        }
    }
    class PowerCatalyst : Supplement
    {
        public PowerCatalyst()
            : base(3, 0, 0)
        {
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            HoldingPen pen = InitializePen();
            StartOperations(pen);
        }
        private static void StartOperations(HoldingPen pen)
        {
            string input = Console.ReadLine();
            while (input != "end")
            {
                pen.ParseCommand(input);
                input = Console.ReadLine();
            }
        }
        private static HoldingPen InitializePen()
        {
            return new HoldingPenModified();
        }
    }
    class Queen : Unit
    {
        public Queen(string name)
            : base(name, UnitClassification.Psionic, 30, 1, 1)
        {
        }
        protected override bool CanAttackUnit(UnitInfo unit)
        {
            bool attackUnit = false;
            if (this.Id != unit.Id && (unit.UnitClassification == UnitClassification.Mechanical || unit.UnitClassification == UnitClassification.Psionic))
            {
                attackUnit = true;
            }
            return attackUnit;
        }
        public override Interaction DecideInteraction(IEnumerable<UnitInfo> units)
        {
            IEnumerable<UnitInfo> attackableUnits = units.Where((unit) => this.CanAttackUnit(unit));
            UnitInfo optimalAttackableUnit = GetOptimalAttackableUnit(attackableUnits);
            if (optimalAttackableUnit.Id != null)
            {
                return new Interaction(new UnitInfo(this), optimalAttackableUnit, InteractionType.Infest);
            }
            return Interaction.PassiveInteraction;
        }
        public override void AddSupplement(ISupplement newSupplement)
        {
            base.AddSupplement(newSupplement);
        }
        protected override UnitInfo GetOptimalAttackableUnit(IEnumerable<UnitInfo> attackableUnits)
        {
            var res = attackableUnits.OrderBy(x => x.Health).LastOrDefault<UnitInfo>();
            return res;
        }
    }
    class Supplement : ISupplement
    {
        public int powerEffect;
        public int healthEffect;
        public int aggressionEffect;
        public Supplement(int power, int health, int aggression)
        {
            this.powerEffect = power;
            this.healthEffect = health;
            this.aggressionEffect = aggression;
        }
        public int PowerEffect
        {
            get { return this.powerEffect; }
        }
        public int HealthEffect
        {
            get { return this.healthEffect; }
        }
        public int AggressionEffect
        {
            get { return this.aggressionEffect; }
        }
        void ISupplement.ReactTo(ISupplement otherSupplement)
        {
            ReactTo1(otherSupplement);
        }
        public virtual void ReactTo1(ISupplement otherSupplement)
        {
        }
        int ISupplement.PowerEffect
        {
            get { return this.powerEffect; }
        }
        int ISupplement.HealthEffect
        {
            get { return this.healthEffect; }
        }
        int ISupplement.AggressionEffect
        {
            get { return this.aggressionEffect; }
        }
    }
    class Tank : Unit
    {
        public Tank(string name)
            : base(name, UnitClassification.Mechanical, 20, 25, 25)
        {
        }
        protected override bool CanAttackUnit(UnitInfo unit)
        {
            bool attackUnit = false;
            if (this.Id != unit.Id)
            {
                attackUnit = true;
            }
            return attackUnit;
        }
        protected override UnitInfo GetOptimalAttackableUnit(IEnumerable<UnitInfo> attackableUnits)
        {
            return attackableUnits.LastOrDefault();
        }
    }
    abstract public class Unit
    {
        public string Id { get; private set; }
        public UnitClassification UnitClassification { get; private set; }
        private int baseHealth;
        private int basePower;
        private int baseAggression;
        public virtual int Health 
        {
            get
            {
                int supplementsBonus = 0;
                foreach (var supplement in this.supplements)
                {
                    supplementsBonus += supplement.HealthEffect;
                }
                return this.baseHealth + supplementsBonus;
            }
        }
        public virtual int Power
        {
            get
            {
                int supplementsBonus = 0;
                foreach (var supplement in this.supplements)
                {
                    supplementsBonus += supplement.PowerEffect;
                }
                return this.basePower + supplementsBonus;
            }
        }
        public virtual int Aggression
        {
            get
            {
                int supplementsBonus = 0;
                foreach (var supplement in this.supplements)
                {
                    supplementsBonus += supplement.AggressionEffect;
                }
                return this.baseAggression + supplementsBonus;
            }
        }
        private ICollection<ISupplement> supplements;
        //public ICollection<ISupplement> Supplements
        //{
        //    get
        //    {
        //        if (this.supplements == null)
        //        {
        //            this.supplements = new List<ISupplement>();
        //        }
        //        return this.supplements;
        //    }
        //    private set
        //    {
        //        this.supplements = value;
        //    }
        //}
        public Unit(string id, UnitClassification unitType, int health, int power, int aggression)
        {
            this.Id = id;
            this.UnitClassification = unitType;
            this.baseHealth = health;
            this.basePower = power;
            this.baseAggression = aggression;
            this.supplements = new List<ISupplement>();
        }
        public void DecreaseBaseHealth(int quantity)
        {
            this.baseHealth -= quantity;
        }
        public virtual void AddSupplement(ISupplement newSupplement)
        {
            foreach (var supplement in this.supplements)
            {
                newSupplement.ReactTo(supplement);
            }
            this.supplements.Add(newSupplement);
        }
        public override string ToString()
        {
            StringBuilder supplementsBuilder = new StringBuilder();
            foreach (var supplement in this.supplements)
            {
                supplementsBuilder.Append(supplement.GetType().Name + ", ");
            }
            if (supplementsBuilder.Length != 0)
            {
                supplementsBuilder.Remove(supplementsBuilder.Length - ", ".Length, ", ".Length); //removing the excess comma-space, coming from the foreach loop above (", ")
            }
            string unitSignature = this.GetType().Name + " " + this.Id + " (" + this.UnitClassification + ")";
            return String.Format("{0} [Health: {1}, Power: {2}, Aggression: {3}, Supplements: [{4}]]",
                unitSignature, this.Health, this.Power, this.Aggression, supplementsBuilder.ToString());
        }
        public virtual Interaction DecideInteraction(IEnumerable<UnitInfo> units)
        {
            IEnumerable<UnitInfo> attackableUnits = units.Where((unit) => this.CanAttackUnit(unit));
            UnitInfo optimalAttackableUnit = GetOptimalAttackableUnit(attackableUnits);
            if (optimalAttackableUnit.Id != null)
            {
                return new Interaction(new UnitInfo(this), optimalAttackableUnit, InteractionType.Attack);
            }
            return Interaction.PassiveInteraction;
        }
        protected virtual UnitInfo GetOptimalAttackableUnit(IEnumerable<UnitInfo> attackableUnits)
        {
            //This method finds the unit with the least power and attacks it
            UnitInfo optimalAttackableUnit = new UnitInfo(null, UnitClassification.Unknown, 0, int.MaxValue, 0);
            foreach (var unit in attackableUnits)
            {
                if (unit.Power < optimalAttackableUnit.Power)
                {
                    optimalAttackableUnit = unit;
                }
            }
            return optimalAttackableUnit;
        }
        protected virtual bool CanAttackUnit(UnitInfo unit)
        {
            bool attackUnit = false;
            if (this.Id != unit.Id)
            {
                if (this.Aggression >= unit.Power)
                {
                    attackUnit = true;
                }
            }
            return attackUnit;
        }
        public UnitInfo Info
        {
            get { return new UnitInfo(this); }
        }
        public virtual bool IsDestroyed
        {
            get
            {
                return this.Health <= 0;
            }
        }
    }
    public enum UnitClassification
    {
        Biological,
        Mechanical,
        Psionic,
        Unknown
    }
    public struct UnitInfo
    {
        public string Id { get; private set; }
        public int Health { get; private set; }
        public int Power { get; private set; }
        public int Aggression { get; private set; }
        public UnitClassification UnitClassification { get; private set; }
        public UnitInfo(string id, UnitClassification unitType, int health, int power, int aggression) : this()
        {
            this.Id = id;
            this.Health = health;
            this.UnitClassification = unitType;
            this.Power = power;
            this.Aggression = aggression;
        }
        public UnitInfo(Unit unit) 
            : this(unit.Id, unit.UnitClassification, unit.Health, unit.Power, unit.Aggression)
        {
        }
    }
    class Weapon : Supplement
    {
        public Weapon()
            : base(0, 0, 0)
        {
        }
        public override void ReactTo1(ISupplement otherSupplement)
        {
            if (otherSupplement is WeaponrySkill)
            {
                base.powerEffect += 10;
                base.aggressionEffect += 3;
            }
        }
    }
    class WeaponrySkill : Supplement
    {
        public WeaponrySkill()
            : base(0, 0, 0)
        {
        }
    }

